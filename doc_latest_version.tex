\documentclass[12pt,a4paper]{article}

% ---------------- Packages ----------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage{physics}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{array}
\usepackage{tikz}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{multicol}

\geometry{top=2cm,bottom=2cm,left=2cm,right=2cm}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small Vibrations de Membranes avec Intel MKL}
\fancyhead[R]{\small \thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Configuration des listings pour le code C
\lstset{
    language=C,
    basicstyle=\footnotesize\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{lightgray!10},
    frame=single,
    rulecolor=\color{black},
    tabsize=2,
    breaklines=true,
    captionpos=b
}

% Définition de commandes personnalisées
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\mkl}{\textbf{Intel MKL}}
\newcommand{\dsygv}{\texttt{dsygv}}

\begin{document}

% ============================================
% PAGE DE GARDE
% ============================================
\begin{titlepage}
\begin{tikzpicture}[remember picture,overlay]
    \draw[line width=3pt, orange!70!red] 
        ([xshift=1cm,yshift=-1cm]current page.north west) 
        rectangle 
        ([xshift=-1cm,yshift=1cm]current page.south east);
    \draw[line width=1.5pt, blue!60] 
        ([xshift=1.3cm,yshift=-1.3cm]current page.north west) 
        rectangle 
        ([xshift=-1.3cm,yshift=1.3cm]current page.south east);
\end{tikzpicture}
\centering
\begin{center}
\begin{minipage}{0.17\textwidth}
    \centering
    \includegraphics[width=1.2\textwidth]{pictures/logo.png}
\end{minipage}
\hfill
\begin{minipage}{0.4\textwidth}
    \centering
{\large \textbf{REPUBLIQUE DU BENIN}}\\[0.2cm]
\rule{5cm}{0.5pt}\\[0.1cm]
\end{minipage}
\hfill
\begin{minipage}{0.17\textwidth}
    \centering
    \includegraphics[width=1.1\textwidth]{pictures/ensgmm.png}
\end{minipage}
\end{center}

{\large \textbf{MINISTÈRE DE L'ENSEIGNEMENT SUPÉRIEUR ET DE LA}}\\
{\large \textbf{RECHERCHE SCIENTIFIQUE (MESRS)}}\\
\rule{10cm}{0.5pt}\\[0.3cm]

{\large \textbf{UNIVERSITÉ NATIONALE DES SCIENCES, TECHNOLOGIES,}}\\
{\large \textbf{INGÉNIERIE ET MATHÉMATIQUES (UNSTIM)}}\\
\rule{10cm}{0.5pt}\\[0.3cm]

{\large \textbf{ÉCOLE NATIONALE SUPÉRIEURE DES GÉNIE MATHÉMATIQUE ET MODÉLISATION}}\\
{\large \textbf{(ENSGMM-ABOMEY)}}\\

\rule{\textwidth}{1.5pt}\\[0.4cm]
{\Huge \textbf{UTILSATION DE INTEL MKL EN}\\[0.3cm]
{\Huge \textbf{CALCUL SCIENTIFIQUE :}}\\[0.3cm]
{\Huge \textbf{BLAS ET LAPACK}}}\\[0.2cm]
\rule{\textwidth}{2pt}\\[1cm]

\begin{flushleft}
    \textbf{Membres du groupe : }\\[0.2cm]
    AHOTONHOUN Aimé Césaire\\[0.2cm]
    BONOU Justus\\[0.2cm]
    HANDJEMEDJI Ezéchiel\\[2cm]
\end{flushleft}

\begin{center}
    {\Large \textbf{PROJET DE CALCUL SCIENTIFIQUE}}\\[0.3cm]
    {\large \textbf{$1^{ère}$ année - CYCLE D'INGÉNIEUR}}\\[0.5cm]
    {\Large \textbf{Sous la supervision de :} Dr. Ing. Carlos AGOSSOU}\\[0.5cm]
\end{center}
\vfill
{\Large \textbf{ANNÉE ACADÉMIQUE : 2025-2026}}

\end{titlepage}

\newpage
\thispagestyle{empty}

\tableofcontents
\newpage

% ============================================
% SECTION 1: INTRODUCTION
% ============================================
\section{Introduction}
\label{sec:introduction}

Les vibrations des membranes sont un phénomène physique fascinant que l'on rencontre dans de nombreux domaines : instruments de musique (tambours), capteurs mécaniques, systèmes d'isolation acoustique, et même en biologie (vibrations des membranes cellulaires). Comprendre ces vibrations permet non seulement de prédire le comportement des systèmes, mais aussi de les concevoir pour des applications spécifiques.

Dans ce projet, nous étudions les vibrations d'une membrane rectangulaire, d'abord dans le cas simple d'une membrane uniforme (avec des propriétés constantes), puis dans le cas plus réaliste d'une membrane non uniforme. Pour la membrane uniforme, nous pouvons trouver une solution exacte grâce à des méthodes mathématiques classiques. Cependant, pour la membrane non uniforme, nous devons recourir à des méthodes numériques avancées.

Intel Math Kernel Library (MKL) est une bibliothèque de calcul haute performance qui nous permet de résoudre efficacement ces problèmes complexes. En particulier, nous utilisons les routines BLAS (Basic Linear Algebra Subprograms) et LAPACK (Linear Algebra PACKage) pour résoudre des problèmes aux valeurs propres de grande taille.

\subsection{Objectifs du projet}
\begin{itemize}
    \item Comprendre la physique des vibrations de membranes
    \item Passer de la solution analytique (membrane uniforme) à la simulation numérique (membrane non uniforme)
    \item Maîtriser l'utilisation d'Intel MKL pour résoudre des problèmes scientifiques complexes
    \item Analyser et visualiser les résultats de manière accessible
\end{itemize}

\subsection{Installation et configuration}

\subsubsection{Installation sur Linux}
\begin{verbatim}
# Méthode 1 : Via le gestionnaire de paquets
sudo apt-get install intel-mkl

# Méthode 2 : Téléchargement depuis le site Intel
# 1. Télécharger le package depuis intel.com
# 2. Extraire et exécuter l'installateur
tar -xzvf l_mkl_2024.0.0.tgz
cd l_mkl_2024.0.0
sudo ./install.sh

# Configuration des variables d'environnement
export MKLROOT=/opt/intel/mkl
export LD_LIBRARY_PATH=$MKLROOT/lib/intel64:$LD_LIBRARY_PATH
\end{verbatim}

\subsubsection{Installation sur Windows}
\begin{itemize}
\item Télécharger Intel oneAPI Base Toolkit depuis le site Intel
\item Exécuter l'installateur graphique
\item Configurer les variables d'environnement dans Visual Studio
\end{itemize}

\subsubsection{Liaison avec un programme C/C++}
\begin{verbatim}
# Compilation avec gcc
gcc -o mon_programme mon_programme.c -lmkl_rt -lpthread -lm -ldl

# Avec Intel Compiler
icc -o mon_programme mon_programme.c -mkl
\end{verbatim}

% ============================================
% SECTION 2: PROBLÈME PHYSIQUE
% ============================================
\section{Vibrations d'une membrane uniforme : solution analytique}
\label{sec:membrane_uniforme}

\subsection{Description physique}
Considérons une membrane mince, homogène et uniformément tendue, fixée sur tout son bord. La membrane occupe un domaine rectangulaire :
\[
\Omega = (0,L_x) \times (0,L_y)
\]
Soit $u(x,y,t)$ le déplacement vertical d'un point $(x,y)$ de la membrane à l'instant $t$. La membrane est caractérisée par :
\begin{itemize}
    \item Une densité surfacique constante $\rho$ (masse par unité de surface)
    \item Une tension constante $T$ (force par unité de longueur)
\end{itemize}

\subsection{Équation des ondes}
L'équation fondamentale qui régit les petites vibrations de la membrane est l'équation des ondes bidimensionnelle :
\begin{equation}
\rho \frac{\partial^2 u}{\partial t^2} = T \Delta u
\end{equation}
où $\Delta$ est le laplacien : $\Delta u = \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}$.

En divisant par $\rho$ et en définissant la vitesse des ondes $c = \sqrt{T/\rho}$, on obtient :
\begin{equation}
\frac{\partial^2 u}{\partial t^2} = c^2 \Delta u
\label{eq:wave_eq}
\end{equation}

Les conditions aux limites de type Dirichlet (bord fixe) sont :
\begin{equation}
u(0,y,t) = u(L_x,y,t) = u(x,0,t) = u(x,L_y,t) = 0
\end{equation}

\subsection{Résolution par séparation des variables}
Nous cherchons des solutions de la forme :
\begin{equation}
u(x,y,t) = X(x)Y(y)G(t)
\end{equation}

En substituant dans l'équation \eqref{eq:wave_eq} et en séparant les variables, nous obtenons trois équations différentielles ordinaires :

\subsubsection{Équation temporelle}
\begin{equation}
G''(t) + c^2 \lambda G(t) = 0
\end{equation}
dont les solutions sont des oscillations sinusoïdales avec fréquence $\omega = c\sqrt{\lambda}$.

\subsubsection{Équations spatiales}
\begin{align}
X''(x) + \lambda_x X(x) &= 0, \quad X(0) = X(L_x) = 0 \\
Y''(y) + \lambda_y Y(y) &= 0, \quad Y(0) = Y(L_y) = 0
\end{align}
avec $\lambda = \lambda_x + \lambda_y$.

\subsection{Solution complète}
Les solutions des équations spatiales sont :
\begin{align}
X_n(x) &= \sin\left(\frac{n\pi x}{L_x}\right), \quad \lambda_x = \left(\frac{n\pi}{L_x}\right)^2 \\
Y_m(y) &= \sin\left(\frac{m\pi y}{L_y}\right), \quad \lambda_y = \left(\frac{m\pi}{L_y}\right)^2
\end{align}
où $n, m = 1, 2, 3, \dots$

Les modes propres de vibration sont donc :
\begin{equation}
\phi_{n,m}(x,y) = \sin\left(\frac{n\pi x}{L_x}\right) \sin\left(\frac{m\pi y}{L_y}\right)
\end{equation}

\subsection{Fréquences propres}
Chaque mode $(n,m)$ vibre à une fréquence propre :
\begin{equation}
\omega_{n,m} = c\sqrt{\left(\frac{n\pi}{L_x}\right)^2 + \left(\frac{m\pi}{L_y}\right)^2}
\end{equation}

\subsection{Interprétation physique}
\begin{itemize}
    \item \textbf{Mode (1,1)} : Toute la membrane se déplace dans le même sens (fondamental)
    \item \textbf{Mode (1,2)} : Une moitié se déplace vers le haut, l'autre vers le bas
    \item \textbf{Mode (2,1)} : Même chose mais selon l'autre direction
    \item \textbf{Mode (2,2)} : Quatre régions alternent haut/bas
\end{itemize}

\section{Problème physique : Vibrations d'une membrane non uniforme}

\subsection{Contexte physique}

On s'intéresse à une membrane carrée de dimension $1 \times 1$ mètre, tendue et fixée sur tout son pourtour. Cette membrane peut représenter divers systèmes physiques :
\begin{itemize}
\item Un \textbf{drum} ou instrument de percussion
\item Un \textbf{capteur vibratoire} en ingénierie
\item Une \textbf{plaque instrumentale} en acoustique
\end{itemize}

La particularité de cette membrane réside dans sa \textbf{non-uniformité} :
\begin{itemize}
\item La tension varie spatialement sur le domaine
\item La densité de masse n'est pas constante
\item Un obstacle central modifie localement la rigidité
\end{itemize}

\subsection{Modèle mathématique continu}

Le comportement vibratoire est décrit par l'équation aux dérivées partielles suivante :

\[
- \nabla \cdot \big( p(x,y) \nabla u(x,y) \big) + q(x,y) u(x,y) = \lambda \, w(x,y) \, u(x,y), 
\quad (x,y) \in \Omega
\]

avec :
\begin{itemize}
\item $\Omega = [0,1] \times [0,1]$ : domaine carré
\item $u(x,y)$ : déplacement vertical (mode propre)
\item $\lambda = \omega^2$ : valeur propre (carré de la fréquence angulaire)
\item $p(x,y)$ : coefficient de tension variable
\item $w(x,y)$ : densité de masse variable
\item $q(x,y)$ : potentiel représentant l'obstacle central
\end{itemize}

\subsection{Conditions aux limites et données}

\subsubsection{Conditions aux limites}
Dirichlet homogène sur tout le bord :
\[
u(x,y) = 0 \quad \text{sur } \partial\Omega
\]

\subsubsection{Fonctions coefficients}
\begin{align*}
p(x,y) &= 1 + 0.5 \sin(2\pi x) \cos(2\pi y) \\
w(x,y) &= 1 + 0.3 x y \\
q(x,y) &= 50 e^{-50[(x-0.5)^2 + (y-0.5)^2]}
\end{align*}

% ============================================
% SECTION 3: DISCRÉTISATION
% ============================================
\section{Discrétisation par différences finies}

\subsection{Maillage du domaine}

On considère un maillage uniforme de $N \times N$ points intérieurs. Le pas spatial est :
\[
h = \frac{1}{N+1}
\]

Les coordonnées des points sont :
\[
x_i = i \cdot h, \quad y_j = j \cdot h, \quad i,j = 0, 1, \dots, N+1
\]

Les points intérieurs (inconnues) sont pour $i,j = 1, \dots, N$.

\subsection{Discrétisation des opérateurs différentiels}

\subsubsection{Opérateur Laplacien avec coefficient variable}

L'opérateur $\nabla \cdot (p \nabla u)$ est discrétisé en utilisant un schéma aux différences finies centrées :

\[
\nabla \cdot (p \nabla u) \approx \frac{1}{h^2} \left[ p_{i+\frac{1}{2},j} (u_{i+1,j} - u_{i,j}) - p_{i-\frac{1}{2},j} (u_{i,j} - u_{i-1,j}) \right]
+ \frac{1}{h^2} \left[ p_{i,j+\frac{1}{2}} (u_{i,j+1} - u_{i,j}) - p_{i,j-\frac{1}{2}} (u_{i,j} - u_{i,j-1}) \right]
\]

où $p_{i+\frac{1}{2},j} = \frac{p_{i,j} + p_{i+1,j}}{2}$ et $p_{i,j+\frac{1}{2}} = \frac{p_{i,j} + p_{i,j+1}}{2}$.

\subsubsection{Discrétisation complète}

Pour chaque point intérieur $(i,j)$, l'équation discrétisée s'écrit :

\begin{multline}
-\frac{1}{h^2}\left[ p_{i+\frac{1}{2},j} (u_{i+1,j} - u_{i,j}) - p_{i-\frac{1}{2},j} (u_{i,j} - u_{i-1,j}) \right] \\
-\frac{1}{h^2}\left[ p_{i,j+\frac{1}{2}} (u_{i,j+1} - u_{i,j}) - p_{i,j-\frac{1}{2}} (u_{i,j} - u_{i,j-1}) \right] \\
+ q_{i,j} u_{i,j} = \lambda w_{i,j} u_{i,j}
\end{multline}

\subsection{Formulation matricielle}

\subsubsection{Numérotation des inconnues}

On utilise une numérotation lexicographique (ligne par ligne) :
\[
k = (i-1) \times N + (j-1), \quad k = 0, \dots, N^2-1
\]

\subsubsection{Construction des matrices}

On obtient un problème aux valeurs propres généralisé de la forme :

\[
A \mathbf{u} = \lambda B \mathbf{u}
\]

où :
\begin{itemize}
\item $\mathbf{u} \in \mathbb{R}^{N^2}$ : vecteur des déplacements aux nœuds
\item $A \in \mathbb{R}^{N^2 \times N^2}$ : matrice de rigidité (creuse, symétrique)
\item $B \in \mathbb{R}^{N^2 \times N^2}$ : matrice de masse (diagonale)
\end{itemize}

\subsubsection{Structure de la matrice $A$}

Pour un nœud intérieur $(i,j)$, les contributions non nulles sont :
\begin{align*}
A_{k,k} &= \frac{1}{h^2}(p_{i+\frac{1}{2},j} + p_{i-\frac{1}{2},j} + p_{i,j+\frac{1}{2}} + p_{i,j-\frac{1}{2}}) + q_{i,j} \\
A_{k,k+1} &= -\frac{1}{h^2} p_{i,j+\frac{1}{2}} \quad (\text{si } j < N) \\
A_{k,k-1} &= -\frac{1}{h^2} p_{i,j-\frac{1}{2}} \quad (\text{si } j > 1) \\
A_{k,k+N} &= -\frac{1}{h^2} p_{i+\frac{1}{2},j} \quad (\text{si } i < N) \\
A_{k,k-N} &= -\frac{1}{h^2} p_{i-\frac{1}{2},j} \quad (\text{si } i > 1)
\end{align*}

\subsubsection{Matrice de masse $B$}

La matrice $B$ est diagonale avec :
\[
B_{k,k} = w_{i,j}
\]

% ============================================
% SECTION 4: SOLVEURS INTEL MKL
% ============================================
\section{Solveurs Intel MKL pour problèmes aux valeurs propres}

\subsection{Classification des solveurs disponibles}

Intel MKL propose plusieurs familles de solveurs pour les problèmes aux valeurs propres :

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Solveur} & \textbf{Type de matrice} & \textbf{Problème} & \textbf{Fonction MKL} \\
\hline
\texttt{dsyev} & Dense, symétrique & Standard & \texttt{LAPACK\_dsyev} \\
\texttt{dsyevd} & Dense, symétrique & Standard (diviser-pour-regner) & \texttt{LAPACK\_dsyevd} \\
\texttt{dsygv} & Dense, symétrique & Généralisé & \texttt{LAPACK\_dsygv} \\
\texttt{dsygvd} & Dense, symétrique & Généralisé (diviser-pour-regner) & \texttt{LAPACK\_dsygvd} \\
\hline
FEAST & Creuse, symétrique & Standard/Généralisé & \texttt{mkl\_sparse\_ee} \\
PARDISO+ & Creuse, symétrique & Standard & \texttt{pardiso\_eigensolver} \\
\hline
\end{tabular}
\caption{Solveurs de valeurs propres dans Intel MKL}
\label{tab:solvers}
\end{table}

\subsection{Solveur \texttt{dsygv} pour matrices denses}

\subsubsection{Description}

Le solveur \texttt{dsygv} résout le problème aux valeurs propres généralisé $A\mathbf{x} = \lambda B\mathbf{x}$ pour des matrices symétriques réelles. Il utilise la réduction au problème standard suivie de l'algorithme QR.

\subsubsection{Interface en C}

\begin{verbatim}
void dsygv(
    int *itype,      // Type de problème (1: A*x = lambda*B*x)
    char *jobz,      // 'N': valeurs propres seulement, 'V': vecteurs aussi
    char *uplo,      // 'U': partie supérieure stockée, 'L': partie inférieure
    int *n,          // Ordre des matrices
    double *A,       // Matrice A
    int *lda,        // Leading dimension de A
    double *B,       // Matrice B
    int *ldb,        // Leading dimension de B
    double *w,       // Valeurs propres
    double *work,    // Tableau de travail
    int *lwork,      // Taille de work
    int *info        // Information de sortie
);
\end{verbatim}

\subsubsection{Complexité algorithmique}

\begin{itemize}
\item Réduction à la forme standard : $O(n^3)$
\item Algorithme QR : $O(n^3)$
\item Stockage : $O(n^2)$
\end{itemize}

\subsection{Choix du solveur pour notre problème}

Bien que la matrice $A$ soit creuse (seulement 5 diagonales non nulles), nous avons opté pour le solveur dense \texttt{dsygv} pour les raisons suivantes :

\begin{enumerate}
\item \textbf{Taille modérée du problème} : Pour $N=50$, nous avons $2500$ degrés de liberté, ce qui donne des matrices de taille $2500 \times 2500$. En format dense, cela nécessite environ 50 Mo de mémoire, ce qui est raisonnable pour les ordinateurs modernes.

\item \textbf{Simplicité d'implémentation} : Le solveur \texttt{dsygv} est plus simple à utiliser que les solveurs creux comme FEAST, qui nécessitent des paramètres de configuration supplémentaires.

\item \textbf{Fiabilité numérique} : \texttt{dsygv} est un solveur éprouvé de LAPACK, garantissant une grande stabilité numérique.

\item \textbf{Extraction de tous les modes} : Contrairement à FEAST qui extrait sélectivement des valeurs propres dans un intervalle, \texttt{dsygv} calcule toutes les valeurs propres, ce qui permet une analyse complète du spectre.
\end{enumerate}

Pour des problèmes plus grands ($N > 100$), il serait nécessaire d'utiliser un solveur adapté aux matrices creuses comme FEAST pour des raisons de mémoire et de temps de calcul.

\subsubsection{Exemple d'utilisation en C}
\begin{lstlisting}[caption=Exemple d'utilisation de dsygv]
#include <mkl.h>

int main() {
    int n = 100;           // Taille du probleme
    int itype = 1;         // Type de probleme
    char jobz = 'V';       // Calculer valeurs et vecteurs propres
    char uplo = 'U';       // Stockage triangle superieur
    
    // Allocation memoire
    double *A = (double*)mkl_malloc(n*n*sizeof(double), 64);
    double *B = (double*)mkl_malloc(n*n*sizeof(double), 64);
    double *w = (double*)mkl_malloc(n*sizeof(double), 64);
    
    // Initialisation des matrices A et B
    // ... (code d'initialisation)
    
    // Calcul de la taille optimale du tableau de travail
    int lwork = -1;
    double work_query;
    dsygv(&itype, &jobz, &uplo, &n, A, &n, B, &n, w, 
          &work_query, &lwork, &info);
    
    lwork = (int)work_query;
    double *work = (double*)mkl_malloc(lwork*sizeof(double), 64);
    
    // Resolution du probleme aux valeurs propres
    dsygv(&itype, &jobz, &uplo, &n, A, &n, B, &n, w, 
          work, &lwork, &info);
    
    // Verification de la reussite
    if (info == 0) {
        printf("Calcul reussi !\n");
    } else {
        printf("Erreur dans le calcul.\n");
    }
    
    // Liberation memoire
    mkl_free(A);
    mkl_free(B);
    mkl_free(w);
    mkl_free(work);
    
    return 0;
}
\end{lstlisting}


% ============================================
% SECTION 5: APPLICATION ET RÉSULTATS
% ============================================
\subsection{Analyse simple pour non-spécialistes}
Imaginez que la membrane est comme la peau d'un tambour. Quand on la frappe, elle vibre à différentes fréquences (des sons plus ou moins aigus). Notre calcul nous donne ces fréquences :

\begin{itemize}
\item \textbf{Fréquence fondamentale (0.240 Hz)} : C'est la note la plus grave que produit la membrane. Toute la membrane bouge dans le même sens, comme une vague unique.
\item \textbf{Fréquences suivantes} : Ce sont des notes plus aiguës où la membrane se divise en zones qui montent et descendent alternativement.
\item \textbf{Presque jumelles (0.491 et 0.500 Hz)} : Ces deux fréquences sont très proches. Dans un tambour parfaitement symétrique, elles seraient identiques. Les petites irrégularités les séparent légèrement.
\end{itemize}

\subsection{Visualisation des modes propres}
Les figures suivantes montrent comment la membrane se déforme pour les cinq premiers modes de vibration :

\begin{figure}[H]
\centering
\begin{subfigure}{0.32\textwidth}
\includegraphics[width=\textwidth]{mode_01.png}
\caption{Mode 1 (0.242 Hz)}
\label{fig:mode1}
\end{subfigure}
\begin{subfigure}{0.32\textwidth}
\includegraphics[width=\textwidth]{mode_02.png}
\caption{Mode 2 (0.494 Hz)}
\label{fig:mode2}
\end{subfigure}
\begin{subfigure}{0.32\textwidth}
\includegraphics[width=\textwidth]{mode_03.png}
\caption{Mode 3 (0.502 Hz)}
\label{fig:mode3}
\end{subfigure}

\vspace{0.5cm}
\begin{subfigure}{0.32\textwidth}
\includegraphics[width=\textwidth]{mode_04.png}
\caption{Mode 4 (0.686 Hz)}
\label{fig:mode4}
\end{subfigure}
\begin{subfigure}{0.32\textwidth}
\includegraphics[width=\textwidth]{mode_05.png}
\caption{Mode 5 (0.962 Hz)}
\label{fig:mode5}
\end{subfigure}
\caption{Les cinq premiers modes de vibration de la membrane non uniforme}
\label{fig:modes}
\end{figure}

\subsubsection{Explication des figures}
\begin{itemize}
    \item \textbf{Zones rouges} : Parties de la membrane présentant un déplacement positif, correspondant à un soulèvement local.
    \item \textbf{Zones bleues} : Parties de la membrane présentant un déplacement négatif, correspondant à un abaissement local.
    \item \textbf{Lignes blanches} : Zones nodales approximatives où le déplacement est nul ou très faible.
    \item \textbf{Point central} : Obstacle situé au centre de la membrane, induisant une perturbation locale du champ de vibration.
\end{itemize}

\subsection{Impact des non-uniformités}
Comparée à une membrane uniforme idéale, la membrane non uniforme étudiée présente les caractéristiques suivantes :
\begin{itemize}
    \item Les fréquences propres sont modifiées par la non-uniformité du matériau et la présence de l’obstacle central.
    \item Les formes modales sont déformées, avec des variations spatiales plus marquées à proximité de l’obstacle.
    \item L’obstacle central peut engendrer, pour certains modes, une zone de déplacement fortement atténué au centre de la membrane.
    \item La répartition des zones nodales perd sa régularité et ne respecte plus les symétries classiques observées dans le cas uniforme.
\end{itemize}

\subsection{Applications pratiques}
L’analyse des vibrations de membranes non uniformes trouve des applications dans plusieurs domaines :
\begin{itemize}
    \item \textbf{Facteurs d’instruments} : Compréhension de l’influence des irrégularités géométriques ou matérielles sur les caractéristiques acoustiques.
    \item \textbf{Ingénierie des vibrations} : Conception et optimisation de membranes destinées à vibrer dans des plages de fréquences spécifiques.
    \item \textbf{Contrôle non destructif} : Détection et localisation de défauts ou d’hétérogénéités par analyse modale et vibratoire.
\end{itemize}


\subsubsection{Exemple concret : un tambour}
Si cette membrane était la peau d'un tambour :
\begin{itemize}
\item Le mode 1 donnerait la note fondamentale (le son principal)
\item Les modes 2-5 donneraient les harmoniques (les sons qui enrichissent le timbre)
\item Les irrégularités créeraient un timbre unique à l'instrument
\item L'obstacle central pourrait être un dispositif d'ajustement de la tension
\end{itemize}

% ============================================
% SECTION 6: PERFORMANCES ET OPTIMISATION
% ============================================
\section{Performances et optimisation avec Intel MKL}

\subsection{Parallélisme et accélération}

Intel MKL a permis d'exploiter efficacement le parallélisme multicœur :
\begin{itemize}
\item \textbf{Accélération} : Le solveur a utilisé 4 threads, réduisant significativement le temps de calcul
\item \textbf{Échelle} : Pour $N=50$, le temps de résolution (8.877 s) est raisonnable pour un problème de cette taille
\item \textbf{Efficacité mémoire} : Malgré l'utilisation du format dense, la mémoire requise (50 Mo) est modeste
\end{itemize}

\subsection{Comparaison avec une implémentation naïve}

Une implémentation naïve de l'algorithme QR aurait une complexité similaire mais serait 10 à 100 fois plus lente due à :
\begin{enumerate}
\item L'absence de vectorisation AVX-512
\item L'absence de parallélisation multithread
\item L'utilisation d'algorithmes non optimisés pour le cache
\item L'inefficacité dans les opérations BLAS de niveau 3
\end{enumerate}

\subsection{Limitations de l'approche dense}

Pour notre problème spécifique :
\begin{itemize}
\item \textbf{Matrice creuse} : La matrice $A$ a seulement 12300 éléments non nuls sur 6.25 millions (0.2\% de remplissage)
\item \textbf{Gaspillage mémoire} : 99.8\% des éléments stockés sont des zéros
\item \textbf{Opérations inutiles} : L'algorithme QR effectue des opérations sur des zéros
\end{itemize}

Ces limitations deviennent critiques pour $N > 100$, où le stockage dense n'est plus possible.

\subsection{Perspective : Solveurs creux pour problèmes plus grands}

Pour des problèmes plus grands, nous recommandons :
\begin{enumerate}
\item \textbf{Format CSR} : Stocker seulement les éléments non nuls
\item \textbf{Solveur FEAST} : Extraire sélectivement les valeurs propres désirées
\item \textbf{Solveur itératif} : Méthode de Lanczos ou Arnoldi pour les très grands problèmes
\end{enumerate}

% ============================================
% ANNEXE : DÉPÔT GITHUB
% ============================================
\section{Dépôt GitHub du projet}

Le code source complet, les données et les scripts de ce projet sont disponibles à l'adresse :

\begin{center}
\large
\href{https://github.com/AyomHead/projet_calcul_scientifique}
     {\texttt{Dépôt github}}
\end{center}

Le dépôt contient :
\begin{itemize}
\item Le code source C avec Intel MKL
\item Les scripts Python de visualisation
\item Les données numériques générées
\item Les figures produites
\item Ce document LaTeX
\end{itemize}


\section{Conclusion}

Intel MKL, à travers ses implémentations optimisées de BLAS et LAPACK, constitue un outil puissant pour le calcul scientifique. Ce projet a montré comment résoudre efficacement un problème physique complexe en combinant modélisation mathématique, discrétisation numérique, et résolution haute performance. Les compétences développées sont transférables à de nombreux domaines de l'ingénierie et de la recherche scientifique.

% ============================================
% RÉFÉRENCES
% ============================================
\begin{thebibliography}{13}
\bibitem{intel2024}
Intel Corporation, \emph{Intel oneAPI Math Kernel Library Developer Reference}, 2024.

\bibitem{saad2011}
Saad, Y., \emph{Numerical Methods for Large Eigenvalue Problems}, SIAM, 2011.

\bibitem{trefethen2000}
Trefethen, L. N., \emph{Spectral Methods in MATLAB}, SIAM, 2000.

\bibitem{polizzi2009}
Polizzi, E., \emph{Density-Matrix-Based Algorithms for Solving Eigenvalue Problems}, Phys. Rev. B, 2009.

\bibitem{bathe2014}
Bathe, K. J., \emph{Finite Element Procedures}, Prentice Hall, 2014.

\bibitem{golub2013}
Golub, G. H., \& Van Loan, C. F., \emph{Matrix Computations (4th ed.)}, Johns Hopkins University Press, 2013.

\bibitem{trefethen1997}
Trefethen, L. N., \& Bau, D., \emph{Numerical Linear Algebra}, SIAM, 1997.

\bibitem{anderson1999}
Anderson, E., et al., \emph{LAPACK Users' Guide (3rd ed.)}, SIAM, 1999.

\bibitem{dongarra1990}
Dongarra, J. J., et al., \emph{A set of level 3 basic linear algebra subprograms}, ACM Transactions on Mathematical Software, 1990.

\bibitem{intel_doc}
Intel Math Kernel Library Developer Reference, \url{https://software.intel.com/content/www/us/en/develop/documentation/mkl-developer-reference-c/top.html}

\bibitem{netlib_blas}
Netlib BLAS Documentation, \url{http://www.netlib.org/blas/}

\bibitem{netlib_lapack}
Netlib LAPACK Documentation, \url{http://www.netlib.org/lapack/}

\bibitem{lapack_notes}
LAPACK Working Notes, \url{http://www.netlib.org/lapack/lawns/}
\end{thebibliography}

\end{document}